#!/usr/bin/env python3
"""
Modified run_CC_CSZ_South.py using K-L expansion for scenario generation
This replaces the problematic k-means approach with physically realistic K-L expansion
"""

from clawpack.geoclaw import dtopotools
import os
import numpy as np
import matplotlib.pyplot as plt
from KL_Scenario_Generation import generate_kl_scenarios, setup_fault_from_csv, subdivide_fault

try:
    CLAW = os.environ['CLAW']
except:
    raise Exception("*** Must first set CLAW enviornment variable")

try:
    import rcrom
except:
    raise Exception("*** rcrom.py not in path: set PYTHONPATH")

# Scratch directory for storing topo and dtopo files:
scratch_dir = os.path.join(CLAW, 'geoclaw', 'scratch')
driver_home = os.getcwd()      # directory where all runs will be done

# ==============================================================================
# setrun, setgeo for the coarse grid runs are defined in setrun.py
# ==============================================================================

from geoclaw_driver.setrun_01 import setrun_coarse, setgeo_coarse

# ==============================================================================
# Iterator for the runs using K-L expansion instead of k-means
# ==============================================================================

def iter_fun(self):
    r"""
    This function will be used to iterate GeoClawInput
    Now using K-L expansion for physically realistic scenario generation
    
    Total runs: 8*M + 2 (8*M runs plus two empty bathymetry runs)
    """

    run_id = self._run_id
    etopo_dir = driver_home
    topodir = driver_home

    # Load fault geometry once
    if not hasattr(self, '_fault_loaded'):
        print("Loading CSZ fault geometry...")
        self._fault = setup_fault_from_csv('CSZe01.csv')
        self._subdivided_fault = subdivide_fault(self._fault, subfault_length=8.0, subfault_width=8.0)
        self._fault_loaded = True

    # Load input info (scenarios generated by K-L expansion)
    if self._input_info == None:
        # Check if K-L scenarios exist, if not generate them
        kl_scenarios_file = 'scenario_pts_kl.txt'
        kl_weights_file = 'scenario_prb_wgts_kl.txt'
        
        if not (os.path.exists(kl_scenarios_file) and os.path.exists(kl_weights_file)):
            print("Generating K-L scenarios...")
            scenarios, weights = generate_kl_scenarios(
                self._subdivided_fault,
                n_scenarios=100,
                n_terms=20,
                Lstrike=130e3,  # 130 km correlation length
                Ldip=40e3,      # 40 km correlation length
                Mw_desired=9.0
            )
            np.savetxt(kl_scenarios_file, scenarios)
            np.savetxt(kl_weights_file, weights)
            print(f"Saved K-L scenarios to {kl_scenarios_file}")
        
        # Load K-L scenarios
        scn = np.loadtxt(kl_scenarios_file)
        scn_list = scn.tolist()
    else:
        scn_list = self._input_info
    
    # Total number of runs
    # M = len(scn_list)
    # N = 8*M + 2     # 8*M runs plus two empty bathymetry runs

    # test mode - can be increased for full runs
    M = 1           # Test mode - can be increased for full runs
    N = 1*M + 2     # 8*M runs plus two empty bathymetry runs

    if run_id == N:
        raise StopIteration()
    else:
        
        #=========================
        # set coarse and fine grids
        #=========================
        t_shelf = 0.   # time approaching continental slope
        t_harbor = 0.  # time approaching harbor

        if ((run_id >= 0) and (run_id < 4*M)) or (run_id == 8*M):
            #------------------
            # setrun for coarse
            #------------------
            grid = 'coarse'
            
            self._rundata.amrdata.amr_levels_max = 4
            # coarse grid run = 10"
            # dx = 30', 5', 1', 10"
            self._rundata.amrdata.refinement_ratios_x = [6, 5, 6]
            self._rundata.amrdata.refinement_ratios_y = [6, 5, 6]
            self._rundata.amrdata.refinement_ratios_t = [6, 5, 6]

            # add topography (coarse)
            topofiles = self._rundata.topo_data.topofiles
            topofiles = []

            topofiles.append([3, 1, 4, 0., 1.e10, \
                    os.path.join(etopo_dir, 'etopo1_-130_-124_38_45_1min.asc')])
            topofiles.append([-3, 3, 4, 0., 1.e10, \
                    os.path.join(topodir, 'cc-1sec.asc')])

            # add regions
            regions = self._rundata.regiondata.regions 
            regions = []
            regions.append(\
                    [2, 3, t_shelf, 1e9, -125, -124.05, 40.5, 43]) 
            regions.append(\
                    [3, 4, t_harbor, 1e9, -124.26, -124.14, 41.67,   41.79])
            regions.append(\
                    [4, 4, t_harbor, 1e9, -124.218,-124.17, 41.7345, 41.77])

            # == fgmax.data values ==
            fgmax_files = self._rundata.fgmax_data.fgmax_files
            fgmax_files = []
            
            fgmax1_fname = os.path.join(driver_home,'fgmax1_coarse.txt')
            fgmax2_fname = os.path.join(driver_home,'fgmax2_coarse.txt')
            fgmax3_fname = os.path.join(driver_home,'fgmax3_coarse.txt')

            fgmax_files.append(fgmax1_fname)  
            fgmax_files.append(fgmax2_fname)  
            fgmax_files.append(fgmax3_fname)  
            
            self._rundata.fgmax_data.num_fgmax_val = 2
        
        elif ((run_id >= 4*M) and (run_id < 8*M)) or (run_id == 8*M+1):
            #----------------
            # setrun for fine
            #----------------
            grid = 'fine'
            
            self._rundata.amrdata.amr_levels_max = 6

            ## fine grid run = 2/3"
            ## dx = 30', 5', 1', 10", 2", 2/3"
            self._rundata.amrdata.refinement_ratios_x = [6, 5, 6, 5, 3]
            self._rundata.amrdata.refinement_ratios_y = [6, 5, 6, 5, 3]
            self._rundata.amrdata.refinement_ratios_t = [6, 5, 6, 5, 3]

            regions = self._rundata.regiondata.regions 
            regions = []
            # between shelf and CC
            regions.append(\
                    [2, 4, t_shelf, 1e9, -125, -124.05, 40.5, 43]) 
            regions.append(\
                    [4, 5, t_harbor, 1e9, -124.26, -124.14, 41.67,   41.79])
            regions.append(\
                    [6, 6, t_harbor, 1e9, -124.218,-124.17, 41.7345, 41.77])

            # add topography (fine)
            topofiles = self._rundata.topo_data.topofiles
            topofiles = []

            topofiles.append([3, 1, 6, 0., 1.e10, \
                    os.path.join(etopo_dir, 'etopo1_-130_-124_38_45_1min.asc')])
            topofiles.append([-3, 4, 6, 0., 1.e10, \
                    os.path.join(topodir, 'cc-1sec.asc')])
            topofiles.append([3, 6, 6, 0., 1.e10, \
                    os.path.join(topodir,'cc-1_3sec-c_pierless.asc')])
            
             # == fgmax.data values ==
            fgmax_files = self._rundata.fgmax_data.fgmax_files
            fgmax_files = []
            
            fgmax1_fname = os.path.join(driver_home,'fgmax1_fine.txt')
            fgmax2_fname = os.path.join(driver_home,'fgmax2_fine.txt')
            fgmax3_fname = os.path.join(driver_home,'fgmax3_fine.txt')

            fgmax_files.append(fgmax1_fname)  
            fgmax_files.append(fgmax2_fname)  
            fgmax_files.append(fgmax3_fname)  
            
            self._rundata.fgmax_data.num_fgmax_val = 2

        #=========================
        # set desired magnitude
        #=========================
        if ((run_id >= 0) and (run_id < M)) \
                            or ((run_id >= 4*M) and (run_id < 5*M)):
            self.KL_Mw_desired = 8.6
        elif ((run_id >= M) and (run_id < 2*M)) \
                            or ((run_id >= 5*M) and (run_id < 6*M)):
            self.KL_Mw_desired = 8.8
        elif ((run_id >= 2*M) and (run_id < 3*M)) \
                            or ((run_id >= 6*M) and (run_id < 7*M)):
            self.KL_Mw_desired = 9.0
        elif ((run_id >= 3*M) and (run_id < 4*M)) \
                            or ((run_id >= 7*M) and (run_id < 8*M)):
            self.KL_Mw_desired = 9.2
        
        #=========================
        # set slip distribution using K-L expansion
        #=========================
        run_id_mod = run_id % 100  # ensures integer index
        m = scn_list[run_id_mod]
        
        # Apply K-L slip distribution to fault
        self.set_KL_slip(m)
    
        if run_id < 8*M:
            dir_grid_Mw = '../geoclaw_output/' + str(grid) + '_' + str(self.KL_Mw_desired)
            self._rundir = os.path.join(dir_grid_Mw, 'run_' + str(run_id_mod))
        else:
            # empty runs to obtain bathymetry
            dir_grid_Mw = '../geoclaw_output/' + str(grid) + '_B0'
            self._rundir = dir_grid_Mw
            self.KL_Mw_desired = 0.0
            self.set_KL_slip([0.]*len(m))   # set output
            self._rundata.clawdata.output_times = [1.0, 3.0]
            
        self._run_id += 1
        
        return self

if __name__=='__main__':
    
    # ==========================================================================
    # Set CSZ fault geometry / parameters
    # ==========================================================================
    
    print("Setting up CSZ fault geometry...")
    
    # Load and subdivide fault
    fault = setup_fault_from_csv('CSZe01.csv')
    subdivided_fault = subdivide_fault(fault, subfault_length=8.0, subfault_width=8.0)
    
    print(f"Original fault: {len(fault.subfaults)} subfaults")
    print(f"Subdivided fault: {len(subdivided_fault.subfaults)} subfaults")
    
    # Generate K-L scenarios if they don't exist
    kl_scenarios_file = 'scenario_pts_kl.txt'
    kl_weights_file = 'scenario_prb_wgts_kl.txt'
    
    if not (os.path.exists(kl_scenarios_file) and os.path.exists(kl_weights_file)):
        print("Generating K-L scenarios...")
        scenarios, weights = generate_kl_scenarios(
            subdivided_fault,
            n_scenarios=100,
            n_terms=20,
            Lstrike=130e3,  # 130 km correlation length
            Ldip=40e3,      # 40 km correlation length
            Mw_desired=9.0
        )
        np.savetxt(kl_scenarios_file, scenarios)
        np.savetxt(kl_weights_file, weights)
        print(f"Saved K-L scenarios to {kl_scenarios_file}")
    else:
        print("Using existing K-L scenarios...")

    # Read topography for contour lines:
    from clawpack.geoclaw.topotools import Topography
    topo = Topography()
    topo.read('../DataFiles/etopo1_-130_-124_38_45_1min.asc',3)

    # ==========================================================================
    # Execute runs using K-L expansion
    # ==========================================================================
    
    print("Starting tsunami simulation with K-L expansion...")
    
    drom0 = rcrom.Drom()    # initialize Drom object
    
    drom0.GeoClawInput.fault = subdivided_fault    # set subdivided fault
    drom0.GeoClawInput.set_iter(iter_fun)   # set iterator
    drom0.GeoClawInput.set_rundata(setrun=setrun_coarse, setgeo=setgeo_coarse)
    drom0.GeoClawInput.KL_expand(Lstrike=130e3, Ldip=40e3,\
                distribution='Lognormal', tau=None, nterms=20, KL_Mw_desired=9.0)
    
    for geoclawinput0 in drom0.GeoClawInput:
        print(geoclawinput0._rundir + ': ' + str(geoclawinput0.KL_Mw_desired))
        drom0.evaluate_hdm()    # run geoclaw
